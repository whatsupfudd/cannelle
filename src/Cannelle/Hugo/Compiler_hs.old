module Cannelle.Hugo.Compiler where

import Control.Monad.State (State, get, put, modify, runState)
import Control.Monad (foldM)

import qualified Data.ByteString as Bs
import Data.Either (isRight)
import Data.Int (Int32)
import Data.List.NonEmpty (NonEmpty (..))
import qualified Data.List as L
import qualified Data.Map as Mp
import Data.Maybe (maybe, fromJust)
import Data.Text (Text, pack)
import qualified Data.Text.Encoding as T
import qualified Data.Vector as V

import qualified Crypto.Hash.MD5 as Cr

import Cannelle.Common.Error (CompError (..), concatErrors)
import Cannelle.VM.OpCodes
import Cannelle.VM.Context (MainText)
import Cannelle.Hugo.Types (GenCompileResult (..), CompContext (..), CompType (..), SimpleType (..))
import qualified Cannelle.Hugo.Types as C
import qualified Cannelle.Hugo.Common as C
import qualified Cannelle.Hugo.Assembler as A
import qualified Cannelle.Hugo.Defines as D
import Cannelle.Hugo.AST


data HugoCompileCtxt = HugoCompileCtxt {
    internalTemplates :: Mp.Map MainText Int32
    , externalTemplates :: Mp.Map MainText Int32
    , blocks :: Mp.Map MainText Int32
  }
  deriving Show

type FullCompContext = CompContext HugoCompileCtxt
type CompileResult = GenCompileResult HugoCompileCtxt ()
type StmtCompRez = GenCompileResult HugoCompileCtxt FStatement
type ExprCompRez = GenCompileResult HugoCompileCtxt FExpression


--- *** Utility functions *** ---
initHugoCompileCtxt :: HugoCompileCtxt
initHugoCompileCtxt = HugoCompileCtxt {
  internalTemplates = Mp.empty
  , externalTemplates = Mp.empty
  , blocks = Mp.empty
}

showHugoCtxt :: FullCompContext -> String
showHugoCtxt = C.showCompContext


-- TODO: implement.
registerVariable :: Variable -> CompType -> State FullCompContext Int32
registerVariable (Variable varKind label) varType = pure 1
-- VarKind = LocalK ($aVar) | MethodK (.aMethod) | LocalMethodK ($.aMethod)

-- TODO: implement.
dereferVariable :: Variable -> State FullCompContext (Maybe Int32)
dereferVariable label = pure Nothing

-- TODO: implement.
registerBlock :: MainText -> State FullCompContext Int32
registerBlock label = pure 0

-- TODO: implement.
getInternalTemplate :: MainText -> State FullCompContext Int32
getInternalTemplate label = pure 0

-- TODO: implement.
getExternalTemplate :: MainText -> State FullCompContext Int32
getExternalTemplate label = pure 0


-- *** AST to OpCodes logic *** ---
compileRawStmts :: MainText -> [RawStatement] -> Either CompError FullCompContext
compileRawStmts funcName stmts =
  -- TODO: find out how to detect errors and pass on to caller.
  let
    newCtx = C.initCompContext funcName initHugoCompileCtxt D.impModules D.impFunctions
    (rezA, finalState) = runState (mapM compileRaw stmts) newCtx
  in
  case concatErrors rezA of
    Nothing -> Right finalState
    Just errs -> Left errs

-- TODO: find all unknowns and resolve their IDs, locations (imports) and types.
resolveStmts :: [FStatement] -> ([FStatement], FullCompContext)
resolveStmts = undefined


-- TODO: generate opcodes from the resolved statements for all functions defined in the FileUnit.
genOpCodes :: [FStatement] -> FullCompContext
genOpCodes = undefined


compileRaw :: RawStatement -> CompileResult
compileRaw stmt@(VarAssignST assignKind identVa valueVa) = do
  eiVarID <- case assignKind of
    DefinitionK -> do
      eiVarID <- dereferVariable identVa
      case eiVarID of
        -- TODO: carry the line number into the statements so they can show up in error messages.
        Just varID -> pure . Left $ CompError [(0, "Variable already defined: " <> show varID)]
        -- TODO: extract type expected from the variable.
        Nothing -> do
          newVarID <- registerVariable identVa UnknownVT
          pure . Right $ stmt
    _ -> do
      mbVarID <- dereferVariable identVa
      case mbVarID of
        Just varID ->
          pure . Right $ stmt
        Nothing -> pure . Left $ CompError [(0, "Variable not found: " <> show identVa)]
  case eiVarID of
    Left err -> pure $ Left err
    Right newVarStmt@(VarAssignST _ nVarID nValueVa) -> do
      compileExpression nValueVa
      A.emitOp $ SET_HEAP 1  -- nVarID


compileRaw (VerbatimST text) = do
  cteID <- A.addVerbatimConstant text
  A.emitOp $ PUSH_CONST cteID
  ctx <- get
  A.emitOp $ REDUCE ctx.spitFctID 1


compileRaw (IfST condExpr thenStmt elseStmt) = do
  notThenLabel <- A.newLabel
  compileExpression condExpr
  A.emitOp CMP_BOOL_IMM
  A.emitOp $ JUMP_FALSE (LabelRef notThenLabel)
  compileRaw thenStmt
  case elseStmt of
    NoOpST ->
      A.setLabelPos notThenLabel
    IfST {} -> do
      sndLabel <- A.newLabel
      A.emitOp $ JUMP (LabelRef sndLabel)
      A.setLabelPos notThenLabel
      compileRaw elseStmt
      A.setLabelPos sndLabel
    _ -> do
      sndLabel <- A.newLabel
      A.emitOp $ JUMP (LabelRef sndLabel)
      A.setLabelPos notThenLabel
      compileRaw elseStmt
      A.setLabelPos sndLabel


compileRaw (RangeST mbVars expr thenStmt elseStmt) = do
  mbValIDs <- case mbVars of
    Just (RangeVars valVar mbIdxVar) -> do
      -- TODO: extract type expected from the variable.
      valID <- registerVariable valVar UnknownVT
      mbIdxID <- case mbIdxVar of
        Nothing -> pure Nothing
        Just aVar -> Just <$> registerVariable aVar (SimpleVT IntST)
      pure $ Just (valID, mbIdxID)
    Nothing -> pure Nothing
  iterLabel <- A.newLabel
  endLabel <- A.newLabel
  -- TODO: figure out how to handle the iterator's implicit looping index variable.
  compileIterator iterLabel mbValIDs expr
  A.emitOp CMP_BOOL_IMM
  case elseStmt of
    NoOpST -> do
      A.emitOp $ JUMP_FALSE (LabelRef endLabel)
      C.pushIterLabels (iterLabel, endLabel)
      compileRaw thenStmt
      A.emitOp $ JUMP (LabelRef iterLabel)
    _ -> do
      elseLabel <- A.newLabel
      A.emitOp $ JUMP_FALSE (LabelRef elseLabel)
      C.pushIterLabels (iterLabel, endLabel)
      compileRaw thenStmt
      A.emitOp $ JUMP (LabelRef iterLabel)
      A.setLabelPos elseLabel
      compileRaw elseStmt
  A.setLabelPos endLabel
  C.popIterLabels


compileRaw (WithST expr thenStmt elseStmt) = do
  -- TODO: extract type expected from the expr and use it to specialise the context variable type:
  withCtxtID <- registerWithContext (StructVT (C.AnonymousSF UnknownVT :| []))
  elseLabel <- A.newLabel
  endLabel <- A.newLabel
  compileExpression expr
  A.emitOp DUP_1
  A.emitOp CMP_BOOL_IMM
  A.emitOp $ JUMP_FALSE (LabelRef elseLabel)
  A.emitOp $ SET_HEAP withCtxtID
  compileRaw thenStmt
  A.emitOp $ JUMP (LabelRef endLabel)
  A.emitOp $ SET_HEAP withCtxtID
  A.setLabelPos elseLabel
  compileRaw elseStmt
  A.setLabelPos endLabel
  where
  -- TODO: implement; it returns the index of a new local variable that will hold the localContext within the
  -- with-block. These can work as a stack.
  registerWithContext :: CompType -> State FullCompContext Int32
  registerWithContext varType = pure 1


compileRaw (ReturnST expr) = do
  compileExpression expr
  -- TODO: put the right number of values to return.
  A.emitOp $ RETURN 0


compileRaw ContinueST = do
  mbIterLabels <- C.getIterLabels
  case mbIterLabels of
    Just (iterLabel, endLabel) -> A.emitOp $ JUMP (LabelRef iterLabel)
    Nothing -> pure . Left $ CompError [(0, "No active loop to continue.")]


compileRaw BreakST = do
  mbIterLabels <- C.getIterLabels
  case mbIterLabels of
    Just (iterLabel, endLabel) -> A.emitOp $ JUMP (LabelRef endLabel)


compileRaw (ExpressionST expr) = do
  ctx <- get
  compileExpression expr
  A.emitOp FORCE_TO_STRING
  A.emitOp $ REDUCE ctx.spitFctID 1


compileRaw (DefineST label body) = do
  C.pushFunctionComp label
  compileRaw body
  -- TODO: check if the define block returns a value.
  -- TODO: put the right number of values to return.
  A.emitOp $ RETURN 0
  C.popFunctionComp


compileRaw (BlockST label contextExpr stmt) = do
  C.pushFunctionComp label
  blockID <- registerBlock label
  -- TODO: figure out how to implement the local context variable.
  localCtx <- registerVariable (Variable LocalK "$blockCtx") (StructVT (C.AnonymousSF UnknownVT :| []))
  compileExpression contextExpr
  A.emitOp $ SET_HEAP localCtx
  A.emitOp $ REDUCE blockID 1
  C.setFunctionContext blockID
  compileRaw stmt
  -- TODO: put the right number of values to return.
  A.emitOp $ RETURN 0
  C.popFunctionComp

compileRaw (IncludeST label expr) = do
  templateID <- getInternalTemplate label
  compileExpression expr
  A.emitOp $ REDUCE templateID 1


compileRaw (PartialST label expr) = do
  templateID <- getExternalTemplate label
  compileExpression expr
  A.emitOp $ REDUCE templateID 1


compileRaw (ListST stmts) = do
  rezA <- mapM compileRaw stmts
  case concatErrors rezA of
    Nothing -> pure $ Right ()
    Just err -> pure $ Left err


compileRaw NoOpST = pure $ Right ()


compileIterator :: Int32 -> Maybe (Int32, Maybe Int32) -> Expression -> CompileResult
compileIterator iterLabel Nothing expr = do
  compileExpression expr
  -- TODO: implement the iterator over the initial expression.
  A.setLabelPos iterLabel

compileIterator iterLabel (Just (idxVarID, Nothing)) expr = do
  compileExpression expr
  A.setLabelPos iterLabel
  -- TODO: implement the iterator over the initial expression.
  A.emitOp IINC_1
  A.emitOp $ SET_HEAP idxVarID
  A.emitOp $ SET_HEAP idxVarID

compileIterator iterLabel (Just (idxVarID, Just varID)) expr = do
  A.emitOp $ SET_VAR_IM1 idxVarID
  compileExpression expr
  A.setLabelPos iterLabel
  -- TODO: implement the iterator over the initial expression.
  A.emitOp $ SET_HEAP varID
  A.emitOp $ GET_HEAP idxVarID
  A.emitOp IINC_1
  A.emitOp $ SET_HEAP idxVarID


compileExpression :: Expression -> CompileResult
compileExpression (ExprLiteral lit) = case lit of
    LitString s -> do
      cteID <- A.addStringConstant s
      A.emitOp $ PUSH_CONST cteID
    LitNumber isFloat n -> A.emitOp $ PUSH_DOUBLE_IMM n
    LitBool b -> A.emitOp $ PUSH_BOOL_IMM b


compileExpression (ExprVariable var@(Variable kind label)) = do
  -- TODO: extract type expected from the variable.
  case kind of
    LocalK -> do
      varID <- registerVariable var (SimpleVT IntST)
      A.emitOp $ GET_HEAP varID
    MethodK -> do
      A.emitOp $ GET_HEAP 0
      lID <- A.addStringConstant label
      A.emitOp $ PUSH_CONST lID
      A.emitOp GET_FIELD
    LocalMethodK -> do
      -- TODO: understand the difference between MethodK and LocalMethodK.
      mbGetLocalCtxID <- C.getImportedFunction "hugo.getLocalContext" []
      case mbGetLocalCtxID of
        Nothing -> pure . Left $ CompError [(0, "Function not found: " <> "hugo.getLocalContext")]
        Just someFcts -> do
          -- TODO: figure out what to do when the function is overloaded.
          let
            (fctDef, fctID) = head someFcts
          A.emitOp $ REDUCE fctID 0
          lID <- A.addStringConstant label
          A.emitOp $ PUSH_CONST lID
          A.emitOp GET_FIELD


-- TODO: assess that the current context is always at the start of the heap.
compileExpression ExprCurrentContext = do
  A.emitOp $ GET_HEAP 0


compileExpression ExprParentContext = do
  contLabel <- A.newLabel
  lID <- A.addStringConstant "$parentCtx"
  A.emitOp $ GET_HEAP 0
  A.emitOp $ PUSH_CONST lID
  A.emitOp GET_FIELD
  A.emitOp $ JUMP_FALSE (LabelRef contLabel)
  A.emitOp $ THROW_ERR 1
  A.setLabelPos contLabel


compileExpression (ExprMethodAccess fields values) = do
  A.emitOp $ GET_HEAP 0
  -- TODO: implement properly.
  mapM_ (\(Variable varKind varName) -> do
      lID <- A.addStringConstant varName
      A.emitOp $ PUSH_CONST lID
      A.emitOp GET_FIELD
    ) fields
  mapM_ compileExpression values
  A.emitOp $ CALL_METHOD (fromIntegral $ length values)


compileExpression (ExprFunctionCall funcName args) = do
  functionID <- C.getFunctionSlot funcName
  rezA <- mapM compileExpression args
  case splitResults rezA of
    (Just err, _) -> pure $ Left err
    (Nothing, argsIDs) ->
      A.emitOp $ REDUCE functionID (fromIntegral $ length args)


compileExpression (ExprPipeline expr functions) = do
  compileExpression expr
  rezB <- mapM (\(FunctionApplication funcName args) -> do
      functionID <- C.getFunctionSlot funcName
      -- TODO: check for errors in rezA.
      rezA <- mapM compileExpression args
      case splitResults rezA of
        (Just err, _) -> pure $ Left err
        (Nothing, argsIDs) ->
          A.emitOp $ REDUCE functionID (1 + fromIntegral (length args))
    ) functions
  case splitResults rezB of
    (Just err, _) -> pure $ Left err
    (Nothing, _) -> pure $ Right ()


splitResults :: [Either CompError a] -> (Maybe CompError, [a])
splitResults results =
  let
    (lefts, rights) = foldl (\(accE, accA) rez -> case rez of
        Left err -> (Left err : accE, accA)
        Right valA -> (accE, valA : accA)
      ) ([], []) results
  in
  (concatErrors lefts, rights)
